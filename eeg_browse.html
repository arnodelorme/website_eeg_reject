<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>EEG CSV Viewer</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      text-align: center;
    }
    #eegCanvas {
      background: #f0f0f0;
      border: 1px solid #ccc;
      display: block;
      margin: 0 auto;
      width: 90%;
    }
    #timeScaleCanvas {
      display: block;
      margin: 0 auto;
      width: 90%;
      height: 50px;
    }
    #voltageScaleCanvas {
      position: absolute;
      left: 0;
      width: 50px;
      height: 200px;
      margin-top: 100px;
    }
    .controls {
      margin: 20px;
    }
  </style>
</head>
<body>
  <h1>EEG Data rejection Browser</h1>
  <div style="position: relative;">
    <canvas id="voltageScaleCanvas"></canvas>
    <canvas id="eegCanvas" width="800" height="600"></canvas>
  </div>
  <canvas id="timeScaleCanvas"></canvas>
  <div class="controls">
    <div style="display: inline-block;">
      <button id="scrollLeft"><<</button>
      <button id="scrollLeftFine"><</button>
      <button id="scrollRightFine">></button>
      <button id="scrollRight">>></button>
    </div>
    <div style="margin-top: 10px;">
      <label for="scaleInput">Vertical Scale (µV):</label>
      <input type="number" id="scaleInput" step="0.01" value="0.2" style="width: 80px;">
    </div>
    <div style="margin-top: 10px;">
      <label for="scrollStepInput">Scroll Step (seconds):</label>
      <input type="number" id="scrollStepInput" step="0.1" value="0.5" style="width: 80px;">
    </div>
    <div style="margin-top: 10px;">
      <label for="secondsVisibleInput">Window Width (seconds):</label>
      <input type="number" id="secondsVisibleInput" step="1" value="5" style="width: 80px;">
    </div>
    <div style="margin-top: 20px;">
      <button id="submitButton">Submit Selections</button>
    </div>
    <div id="selectionInfo" style="margin-top: 20px; text-align: left; display: none;">
      <div>
        <h3>Channel States:</h3>
        <div id="channelStatesList"></div>
      </div>
      <div style="margin-top: 10px;">
        <h3>Time Selections:</h3>
        <div id="timeSelectionsList"></div>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const sampleRate = 256;                 // samples per second
    let secondsVisible = 20;                 // changed to variable
    let samplesVisible = sampleRate * secondsVisible; // changed to variable
    let scrollStep = Math.floor(sampleRate * 20);
    let verticalScale = 0.01;              // Initialize scale as 1/microvolts

    // Global variables
    let eegData = [];
    let windowStart = 0;
    let selections = [];        // Array to store multiple selections
    let isSelecting = false;    // Flag to track if we're currently selecting
    let selectionStart = null;  // Temporary selection start while dragging
    let lastMouseX = 0;
    let channelStates = new Map();  // Store channel states: 0=normal, 1=highlighted, 2=hidden

    const canvas = document.getElementById('eegCanvas');
    const ctx = canvas.getContext('2d');

    // Add new scale drawing code
    const timeScaleCanvas = document.getElementById('timeScaleCanvas');
    const voltageScaleCanvas = document.getElementById('voltageScaleCanvas');
    const timeCtx = timeScaleCanvas.getContext('2d');
    const voltageCtx = voltageScaleCanvas.getContext('2d');

    function drawScales() {
      // Time scale
      timeScaleCanvas.width = window.innerWidth; // - 40;
      timeScaleCanvas.height = 50;
      
      // Calculate width for 1 second based on current display settings
      const oneSecondPixels = (canvas.width / secondsVisible); // pixels per second
      
      timeCtx.beginPath();
      timeCtx.moveTo(50, 20);
      timeCtx.lineTo(50 + oneSecondPixels, 20);
      
      // Time scale vertical ends
      timeCtx.moveTo(50, 15);
      timeCtx.lineTo(50, 25);
      timeCtx.moveTo(50 + oneSecondPixels, 15);
      timeCtx.lineTo(50 + oneSecondPixels, 25);
      
      timeCtx.strokeStyle = 'black';
      timeCtx.stroke();
      
      // Time scale label
      timeCtx.font = '12px Arial';
      timeCtx.textAlign = 'center';
      timeCtx.fillText('1 second', 50 + oneSecondPixels/2, 40);

      // Voltage scale
      voltageScaleCanvas.width = 50;
      voltageScaleCanvas.height = 200;
      
      // Calculate height for 100 µV based on current vertical scale
      const channelHeight = canvas.height / eegData.length;
      const voltageBarHeight = 100 * (channelHeight/2) * verticalScale;  // height for 100 µV
      
      voltageCtx.beginPath();
      voltageCtx.moveTo(25, 50);
      voltageCtx.lineTo(25, 50 + voltageBarHeight);
      
      // Voltage scale horizontal ends
      voltageCtx.moveTo(20, 50);
      voltageCtx.lineTo(30, 50);
      voltageCtx.moveTo(20, 50 + voltageBarHeight);
      voltageCtx.lineTo(30, 50 + voltageBarHeight);
      
      voltageCtx.strokeStyle = 'black';
      voltageCtx.stroke();
      
      // Voltage scale label
      voltageCtx.save();
      voltageCtx.translate(15, 50 + voltageBarHeight/2);
      voltageCtx.rotate(-Math.PI/2);
      voltageCtx.textAlign = 'center';
      voltageCtx.fillText('100 µV', 0, 0);
      voltageCtx.restore();
    }

    // Call drawScales on window resize and initial load
    window.addEventListener('resize', drawScales);
    drawScales();

    // Function to resize canvas
    function resizeCanvas() {
      const padding = 40; // Account for body margins
      canvas.width = window.innerWidth - padding;
      draw(); // Redraw after resize
    }

    // Add window resize listener
    window.addEventListener('resize', resizeCanvas);

    // Initial canvas size setup
    resizeCanvas();

    // Fetch and parse the CSV file
    fetch('raw_data.csv')
      .then(response => response.text())
      .then(text => {
        // Split by newline to get rows
        const rows = text.trim().split('\n').map(row => row.split(',').map(val => parseFloat(val)));
        // Transpose the data so that each array represents one channel
        const numChannels = rows[0].length;
        eegData = Array.from({ length: numChannels }, () => []);
        rows.forEach(row => {
          row.forEach((value, colIndex) => {
            eegData[colIndex].push(value);
          });
        });
        
        // Initialize everything after data is loaded
        resizeCanvas();
        draw();
        drawScales();
        
        // Initialize input values
        scaleInput.value = 10;  // Show 0.2 for 200 µV range
        verticalScale = 200 / (scaleInput.value * 1000);  // Set initial scale
        secondsVisibleInput.value = secondsVisible;
        scrollStepInput.value = scrollStep / sampleRate;
        
        // Redraw with initial values
        draw();
        drawScales();
      })
      .catch(error => {
        console.error('Error loading CSV file:', error);
      });

    // Draw the current window of data for all channels
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!eegData.length) return; // no data to draw

      const numChannels = eegData.length;
      const channelHeight = canvas.height / numChannels;

      // For each channel, draw its data in its own horizontal band.
      for (let ch = 0; ch < numChannels; ch++) {
        const channelState = channelStates.get(ch) || 0;
        // Skip hidden channels
        if (channelState === 2) continue;

        const channelData = eegData[ch];
        const totalSamples = channelData.length;
        // Ensure we don't exceed available data.
        const windowEnd = Math.min(windowStart + samplesVisible, totalSamples);

        ctx.beginPath();
        for (let i = windowStart; i < windowEnd; i++) {
          // x coordinate is proportional to the position within the visible window
          const x = ((i - windowStart) / samplesVisible) * canvas.width;
          // Modified scale calculation
          const scale = (channelHeight / 2) * verticalScale;  
          const baseline = ch * channelHeight + channelHeight / 2;
          // Invert the value so that larger values appear upward.
          const y = baseline - (channelData[i] * scale);

          if (i === windowStart) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        // Set stroke color based on channel state
        ctx.strokeStyle = channelState === 1 ? 'red' : 'black';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Draw a horizontal line at the baseline for reference.
        ctx.beginPath();
        ctx.moveTo(0, ch * channelHeight + channelHeight / 2);
        ctx.lineTo(canvas.width, ch * channelHeight + channelHeight / 2);
        ctx.strokeStyle = '#ccc';
        ctx.stroke();
      }

      // Draw all saved selections
      selections.forEach((selection, index) => {
        const startX = ((selection.start - windowStart) / samplesVisible) * canvas.width;
        const endX = ((selection.end - windowStart) / samplesVisible) * canvas.width;
        
        // Draw semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 123, 255, 0.2)';
        ctx.fillRect(
          Math.min(startX, endX), 
          0, 
          Math.abs(endX - startX), 
          canvas.height
        );
        
        // Draw vertical lines at selection boundaries
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
        ctx.setLineDash([5, 5]);
        ctx.moveTo(startX, 0);
        ctx.lineTo(startX, canvas.height);
        ctx.moveTo(endX, 0);
        ctx.lineTo(endX, canvas.height);
        ctx.stroke();
        ctx.setLineDash([]);
      });

      // Draw current selection while dragging
      if (isSelecting && selectionStart !== null) {
        const currentSampleIndex = getMouseSampleIndex(lastMouseX);
        const startX = ((selectionStart - windowStart) / samplesVisible) * canvas.width;
        const endX = ((currentSampleIndex - windowStart) / samplesVisible) * canvas.width;
        
        ctx.fillStyle = 'rgba(0, 123, 255, 0.2)';
        ctx.fillRect(
          Math.min(startX, endX), 
          0, 
          Math.abs(endX - startX), 
          canvas.height
        );
        
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
        ctx.setLineDash([5, 5]);
        ctx.moveTo(startX, 0);
        ctx.lineTo(startX, canvas.height);
        ctx.moveTo(endX, 0);
        ctx.lineTo(endX, canvas.height);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Convert mouse X position to sample index
    function getMouseSampleIndex(mouseX) {
      const rect = canvas.getBoundingClientRect();
      const x = mouseX - rect.left;
      const sampleOffset = (x / canvas.width) * samplesVisible;
      return Math.floor(windowStart + sampleOffset);
    }

    // Check if a point is within a selection
    function isPointInSelection(sampleIndex, selection) {
      const minIndex = Math.min(selection.start, selection.end);
      const maxIndex = Math.max(selection.start, selection.end);
      return sampleIndex >= minIndex && sampleIndex <= maxIndex;
    }

    // Get channel index from mouse Y position
    function getChannelFromY(mouseY) {
      const rect = canvas.getBoundingClientRect();
      const voltageScaleCanvas = document.getElementById('voltageScaleCanvas');
      const timeScaleCanvas = document.getElementById('timeScaleCanvas');
      const voltageRect = voltageScaleCanvas.getBoundingClientRect();
      const timeRect = timeScaleCanvas.getBoundingClientRect();
      
      const y = mouseY - rect.top;  // Account for voltage scale offset
      const channelHeight = canvas.height / eegData.length;
      return Math.floor(y / (channelHeight-2)); // Const 2 here is not ideal, but it works
    }
    
    // Mouse event handlers
    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 0) { // Left click
        const clickedSampleIndex = getMouseSampleIndex(e.clientX);
        
        // Check if click is within any existing selection
        const clickedSelectionIndex = selections.findIndex(selection => 
          isPointInSelection(clickedSampleIndex, selection)
        );

        if (clickedSelectionIndex !== -1) {
          // Remove the clicked selection
          selections.splice(clickedSelectionIndex, 1);
          draw();
        } else {
          // Start potential selection
          isSelecting = true;
          selectionStart = clickedSampleIndex;
          lastMouseX = e.clientX;
          draw();
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isSelecting) {
        lastMouseX = e.clientX;
        draw();
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (isSelecting) {
        const selectionEnd = getMouseSampleIndex(e.clientX);
        if (Math.abs(selectionEnd - selectionStart) > 1) {
          // If dragged, create a selection
          selections.push({
            start: selectionStart,
            end: selectionEnd
          });
        } else {
          // If clicked without dragging, cycle channel state
          const clickedChannel = getChannelFromY(e.clientY);
          const currentState = channelStates.get(clickedChannel) || 0;
          const nextState = (currentState + 1) % 3; // Cycle through 0, 1, 2
          if (nextState === 0) {
            channelStates.delete(clickedChannel); // Remove normal state from map
          } else {
            channelStates.set(clickedChannel, nextState);
          }
        }
        isSelecting = false;
        selectionStart = null;
        draw();
      }
    });

    canvas.addEventListener('mouseleave', (e) => {
      if (isSelecting) {
        const selectionEnd = getMouseSampleIndex(e.clientX);
        if (Math.abs(selectionEnd - selectionStart) > 1) {
          selections.push({
            start: selectionStart,
            end: selectionEnd
          });
        }
        isSelecting = false;
        selectionStart = null;
        draw();
      }
    });

    // Update the display when scrolling
    function scrollData(direction, isFine = false) {
      if (!eegData.length) return;

      const step = isFine ? Math.floor(scrollStep / 5) : scrollStep;
      const totalSamples = eegData[0].length;
      
      if (direction === 'left') {
        windowStart = Math.max(0, windowStart - step);
      } else if (direction === 'right') {
        windowStart = Math.min(totalSamples - samplesVisible, windowStart + step);
      }
      draw();
    }

    // Set up button event listeners
    document.getElementById('scrollLeft').addEventListener('click', () => {
      scrollData('left');
    });
    document.getElementById('scrollRight').addEventListener('click', () => {
      scrollData('right');
    });
    document.getElementById('scrollLeftFine').addEventListener('click', () => {
      scrollData('left', true);
    });
    document.getElementById('scrollRightFine').addEventListener('click', () => {
      scrollData('right', true);
    });

    // Set up scale input event listener
    const scaleInput = document.getElementById('scaleInput');
    scaleInput.addEventListener('input', (e) => {
      const displayValue = parseFloat(e.target.value);
      if (!isNaN(displayValue) && displayValue > 0) {
        const microvolts = displayValue * 1000;  // Convert display value to microvolts
        verticalScale = 200 / microvolts;  // Inverse relationship: larger µV = smaller scale
        draw();
        drawScales();
      }
    });

    // Set up scroll step input event listener
    const scrollStepInput = document.getElementById('scrollStepInput');
    scrollStepInput.addEventListener('input', (e) => {
      const newStepSeconds = parseFloat(e.target.value);
      if (!isNaN(newStepSeconds) && newStepSeconds > 0) {
        scrollStep = Math.floor(sampleRate * newStepSeconds);
      }
    });

    // Set up seconds visible input event listener
    const secondsVisibleInput = document.getElementById('secondsVisibleInput');
    secondsVisibleInput.addEventListener('input', (e) => {
      const newSeconds = parseFloat(e.target.value);
      if (!isNaN(newSeconds) && newSeconds > 0) {
        secondsVisible = newSeconds;
        samplesVisible = sampleRate * secondsVisible;
        draw();
      }
    });

    // Add submit button handler
    document.getElementById('submitButton').addEventListener('click', () => {
      const selectionInfo = document.getElementById('selectionInfo');
      const channelStatesList = document.getElementById('channelStatesList');
      const timeSelectionsList = document.getElementById('timeSelectionsList');
      
      // Clear previous info
      channelStatesList.innerHTML = '';
      timeSelectionsList.innerHTML = '';
      
      // Display channel states
      const highlightedChannels = [];
      const hiddenChannels = [];
      channelStates.forEach((state, channel) => {
        if (state === 1) highlightedChannels.push(channel);
        if (state === 2) hiddenChannels.push(channel);
      });
      
      if (highlightedChannels.length > 0) {
        channelStatesList.innerHTML += `<p>Highlighted (red) channels: ${highlightedChannels.join(', ')}</p>`;
      }
      if (hiddenChannels.length > 0) {
        channelStatesList.innerHTML += `<p>Hidden channels: ${hiddenChannels.join(', ')}</p>`;
      }
      if (highlightedChannels.length === 0 && hiddenChannels.length === 0) {
        channelStatesList.innerHTML = '<p>No channels modified</p>';
      }

      // Display time selections
      if (selections.length > 0) {
        selections.forEach((selection, index) => {
          const startTime = (selection.start / sampleRate).toFixed(2);
          const endTime = (selection.end / sampleRate).toFixed(2);
          timeSelectionsList.innerHTML += `
            <p>Selection ${index + 1}: ${startTime}s to ${endTime}s 
            (samples ${selection.start} to ${selection.end})</p>`;
        });
      } else {
        timeSelectionsList.innerHTML = '<p>No time ranges selected</p>';
      }

      // Show the info div
      selectionInfo.style.display = 'block';
    });

    // Call drawScales whenever the scale parameters change
    scaleInput.addEventListener('input', drawScales);
    secondsVisibleInput.addEventListener('input', drawScales);
  </script>
</body>
</html>
